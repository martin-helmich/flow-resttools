TYPO3 Flow REST toolkit
=======================

Author
------

Martin Helmich <typo3@martin-helmich.de>

Synopsis
--------

This package contains a set of helper classes for implementing RESTful
webservices with TYPO3 Flow.

It specifically handles the following concerns:

- Controller configuration
- Serializing domain objects

Controller configuration
------------------------

This package offers a [RestController](Classes/Helmich/RestTools/Mvc/Controller/RestController.php)
that you may use when implementing controllers. Please note that this class
**does not** extend Flow's own `RestController` class.

The `RestController` class contains a default view configuration that enables
the controller to support JSON, YAML, XML and MSGPACK representations
(currently, output only. Input is still handled by Flow's default MediaConverter,
which supports only JSON and XML). Stay tuned for more.

Serializing domain objects
--------------------------

This package contains an API for converting domain objects into representations.
Unlike TYPO3 Flow's `JsonView`, which relies on automatically building the
representation based on values returned by an object's getter method, this
package requires explicit normalizer classes to be supplied for each domain
model. I prefer this design because it offers more control on how object
representations are generated.

In general, object serialization is performed in two steps:

- *Normalization*: Convert domain objects into a plain PHP array. This step is
  domain-specific. This means that you have to specify a *Normalizer* class for
  each domain object you want to present. These classes have to implement the
  `NormalizerInterface` (see [source](Classes/Helmich/RestTools/Rest/Normalizer/NormalizerInterface))
  and return a scalar PHP type -- usually a (nested) array.

- *Serialization*: Converts scalar PHP types generated by the normalization
  step into a string represantation. This step is *not* domain-specific.
  Currently, there are normalizers for JSON, YAML and [MessagePack](http://msgpack.org).

Example
-------

Consider a simple domain object `My\Example\Domain\Model\Product` with the
properties *name* and *quantity*.

First, implement a Normalizer for converting instances of these class to a
scalar value:

```php
<?php
namespace My\Example\RestApi\Normalizer;

use Helmich\RestTools\Rest\Normalizer\NormalizerInterface;
use My\Example\Domain\Model\Product;
use TYPO3\Flow\Annotations as Flow;
use TYPO3\Flow\Persistence\PersistenceManagerInterface;

class ProductNormalizer implements NormalizerInterface
{
  /**
   * @var PersistenceManagerInterface
   * @Flow\Inject
   */
  protected $persistenceManager;

  public function objectToScalar($object)
  {
    if ($object instanceof Product) {
      return [
        'id'              => $this->persistenceManager->getIdentifierByObject($object),
        'name'            => $object->getName(),
        'amount_in_stock' => $object->getQuantity()
      ];
    }
  }
}
```

In your controller, you can then wire this normalizer to your entity class:

```php
<?php
namespace My\Example\Controller;

use My\Example\Domain\Model\Product;
use My\Example\Domain\Repository\ProductRepository;
use My\Example\RestApi\Normalizer\ManufacturerNormalizer;
use Helmich\RestTools\Mvc\Controller\RestController;
use Helmich\RestTools\Mvc\View\SerializingViewInterface;
use TYPO3\Flow\Annotations as Flow;
use TYPO3\Flow\Mvc\View\ViewInterface;

class ProductController extends RestController
{
  /**
   * @var ProductRepository
   * @Flow\Inject
   */
  protected $productRepository;

  public function initializeView(ViewInterface $view)
  {
    if ($view instanceof SerializingViewInterface) {
      $view->registerNormalizerForClass(Product::class, new new ProductNormalizer());
    }
  }

  public function listAction()
  {
    $this->view->assign('products', $this->productRepository->findAll());
  }
}
```
